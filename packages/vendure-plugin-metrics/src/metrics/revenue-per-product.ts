import {
  Injector,
  Logger,
  Order,
  OrderLine,
  ProductVariant,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { AdvancedMetricType } from '../ui/generated/graphql';
import { MetricStrategy, NamedDatapoint } from '../services/metric-strategy';
import { loggerCtx } from '../constants';
import { Visit } from '../services/request-service';

/**
 * Calculates the revenue generated by each product variant.
 * calculates the total revenue if no variants are provided.
 */
export class RevenuePerProduct implements MetricStrategy {
  readonly metricType: AdvancedMetricType = AdvancedMetricType.Currency;
  readonly code = 'revenue-per-product';
  readonly allowProductSelection = true;

  getTitle(ctx: RequestContext): string {
    return `Revenue`;
  }

  calculateDataPoints(
    ctx: RequestContext,
    orders: Order[],
    visits: Visit[],
    variants: ProductVariant[]
  ): NamedDatapoint[] {
    if (!variants.length) {
      // Return total revenue
      let legendLabel = 'Total Revenue';
      if (ctx.channel.pricesIncludeTax) {
        legendLabel += ' (incl. tax)';
      } else {
        legendLabel += ' (excl. tax)';
      }
      const totalFieldName = ctx.channel.pricesIncludeTax
        ? 'totalWithTax'
        : 'total';
      const totalRevenue = orders.reduce(
        (total, current) => total + current[totalFieldName],
        0
      );
      return [
        {
          legendLabel,
          value: totalRevenue / 100,
        },
      ];
    }
    // Else calculate revenue per variant
    // Map orders to lines, but st the order object on each line
    const lines = orders
      .map((order) => {
        order.lines.forEach((l) => (l.order = order));
        return order.lines;
      })
      .flat();
    const dataPoints: NamedDatapoint[] = [];
    const totalFieldName = ctx.channel.pricesIncludeTax
      ? 'proratedLinePriceWithTax'
      : 'proratedLinePrice';
    variants.forEach((variant) => {
      // Find order lines per variant id
      const linesForVariant = lines.filter(
        (line) => line.productVariant.id === variant.id
      );
      // Sum of order lines with this variant

      const revenue = linesForVariant.reduce(
        (total, current) => total + current[totalFieldName],
        0
      );
      dataPoints.push({
        legendLabel: variant.name,
        value: revenue / 100,
      });
    });
    return dataPoints;
  }
}
